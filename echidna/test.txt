/Users/simonbusch/code/audit/beraborrow/blockend/src/core/vaults/TestContract.sol.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     |
   3 |     | pragma solidity 0.8.26;
   4 |     |
   5 |     | import {ERC4626Upgradeable, ERC20Upgradeable, IERC20, Math, SafeERC20} from "@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol";
   6 |     | import {Ownable2StepUpgradeable} from "@openzeppelin-upgradeable/contracts/access/Ownable2StepUpgradeable.sol";
   7 |     | import {UUPSUpgradeable} from "@openzeppelin-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol";
   8 |     | import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
   9 |     | import {PriceLib} from "../../libraries/PriceLib.sol";
  10 |     | import {IDenManager} from "../../interfaces/core/IDenManager.sol";
  11 |     | import {IPriceFeed} from "../../interfaces/core/IPriceFeed.sol";
  12 |     | import {IBeraborrowCore} from "../../interfaces/core/IBeraborrowCore.sol";
  13 |     | import {IInfraredCollateralVault} from "../../interfaces/core/vaults/IInfraredCollateralVault.sol";
  14 |     | import {IRebalancer} from "../../interfaces/utils/integrations/IRebalancer.sol";
  15 |     | import {IAsset} from "../../interfaces/utils/tokens/IAsset.sol";
  16 |     | import {IIBGTVault} from "../../interfaces/core/vaults/IIBGTVault.sol";
  17 |     | import {IInfraredVault} from "../../interfaces/utils/integrations/IInfraredVault.sol";
  18 |     |
  19 |     | /**
  20 |     |  * @title Beraborrow Infrared Collateral Vault
  21 |     |  * @notice Supercharges DenManager with PoL
  22 |     |  */
  23 |     | abstract contract InfraredCollateralVault is ERC4626Upgradeable, UUPSUpgradeable {
  24 |     |     using Math for uint;
  25 |     |     using SafeERC20 for IERC20;
  26 |     |     using EnumerableSet for EnumerableSet.AddressSet;
  27 |     |     using PriceLib for uint;
  28 |     |
  29 | *   |     uint internal constant BP = 1e4;
  30 | *   |     uint internal constant WAD = 1e18;
  31 |     |
  32 |     |     // keccak256(abi.encode(uint(keccak256("openzeppelin.storage.InfraredCollateralVault")) - 1)) & ~bytes32(uint(0xff))
  33 |     |     bytes32 private constant InfraredCollateralVaultStorageLocation = 0xf6a35052099d23fafed8c58b549933969c057c5a9a13ac5133024adc8dd4f200;
  34 |     |
  35 |     |     struct InfraredCollVaultStorage {
  36 |     |         uint16 minPerformanceFee;
  37 |     |         uint16 maxPerformanceFee;
  38 |     |         uint16 performanceFee; // over yield, in basis points
  39 |     |
  40 |     |         address iRedToken;
  41 |     |         /// @dev We currently don't know the infraredVault implementation, but if it were to be possible for them to remove tokens from the rewardTokens
  42 |     |         /// There would be no need to remove it from here since the amounts should continue being accounted for in the virtual balance
  43 |     |         EnumerableSet.AddressSet rewardedTokens;
  44 |     |
  45 |     |         IBeraborrowCore _beraborrowCore;
  46 |     |         IInfraredVault _infraredVault;
  47 |     |         address ibgtVault;
  48 |     |         address ibgt;
  49 |     |         uint96 lastUpdate;
  50 |     |
  51 |     |         mapping(address token => uint) balance;
  52 |     |         mapping(bytes32 tokenIn => uint) threshold;
  53 |     |
  54 |     |     }
  55 |     |
  56 | *   |     function _getInfraredCollVaultStorage() internal pure returns (IInfraredCollateralVault.InfraredCollVaultStorage storage store) {
  57 |     |         assembly {
  58 | *   |             store.slot := InfraredCollateralVaultStorageLocation
  59 |     |         }
  60 |     |     }
  61 |     |
  62 |     |     constructor() {
  63 | *   |         _disableInitializers();
  64 |     |     }
  65 |     |
  66 | *   |     function __InfraredCollateralVault_init(IInfraredCollateralVault.InfraredInitParams calldata params) internal onlyInitializing {
  67 | *   |         __InfraredCollateralVault_init_unchained(params);
  68 |     |     }
  69 |     |
  70 | *   |     function __InfraredCollateralVault_init_unchained(IInfraredCollateralVault.InfraredInitParams calldata params) internal onlyInitializing {
  71 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
  72 |     |
  73 | *   |         if (params.iRedToken == address(0) || address(params._beraborrowCore) == address(0) || address(params._infraredVault) == address(0) || params._ibgtVault == address(0) || address(params._asset) == address(0)) {
  74 |     |             revert("CollVault: 0 address");
  75 |     |         }
  76 |     |
  77 | *   |         IPriceFeed priceFeed = IPriceFeed(params._beraborrowCore.priceFeed());
  78 | *   |         require(priceFeed.fetchPrice(address(params._asset)) != 0, "LSP: asset price feed not set up");
  79 | *   |         require(params.minPerformanceFee <= params.maxPerformanceFee && params.maxPerformanceFee <= BP, "CollVault: Incorrect min/max performance fee");
  80 | *   |         require(params.performanceFee >= params.minPerformanceFee && params.performanceFee <= params.maxPerformanceFee, "CollVault: performance fee out of bounds");
  81 | *   |         require(params._infraredVault.stakingToken() == address(params._asset), "CollVault: stakingToken mismatch");
  82 |     |
  83 | *   |         $.minPerformanceFee = params.minPerformanceFee;
  84 | *   |         $.maxPerformanceFee = params.maxPerformanceFee;
  85 |     |
  86 | *   |         $.performanceFee = params.performanceFee;
  87 |     |
  88 | *   |         $.iRedToken = params.iRedToken; // this set assumes that the iRedToken is a reward token in all InfraredVaults, which may not be the case
  89 | *   |         $._beraborrowCore = params._beraborrowCore;
  90 | *   |         $._infraredVault = params._infraredVault;
  91 | *   |         $.ibgtVault = params._ibgtVault;
  92 |     |
  93 | *   |         __ERC20_init(params._sharesName, params._sharesSymbol);
  94 | *   |         __ERC4626_init(params._asset);
  95 |     |
  96 | *   |         $.ibgt = address(this) == params._ibgtVault ? address(params._asset) : IIBGTVault(params._ibgtVault).asset();
  97 |     |
  98 |     |         // so we don't have to approve() every time we stake
  99 | *   |         IERC20(params._asset).approve(address(params._infraredVault), type(uint256).max);
 100 |     |     }
 101 |     |
 102 |     |     modifier onlyOwner {
 103 | *   |         _onlyOwner();
 104 |     |         _;
 105 |     |     }
 106 |     |
 107 | *   |     function _onlyOwner() private view {
 108 |     |         // Owner is beacon variable BeraborrowCore::owner()
 109 | *   |         require(msg.sender == getBeraborrowCore().owner(), "CollVault: caller is not the owner");
 110 |     |     }
 111 |     |
 112 | *   |     function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
 113 |     |
 114 |     |     // Compound iBGT rewards
 115 |     |     /// @dev Since we are not accepting donations, we won't `stake` ibgt.balanceOf(this)
 116 |     |     modifier harvestRewards() {
 117 | *   |         _harvestRewards();
 118 |     |         _;
 119 |     |     }
 120 |     |
 121 | *   |     function _harvestRewards() private {
 122 | *   |         if (block.timestamp == _getInfraredCollVaultStorage().lastUpdate) return;
 123 |     |
 124 | *   |         IInfraredVault iVault = infraredVault();
 125 | *   |         (address[] memory tokens, uint tokensLength) = _getVaultRewardTokens();
 126 | *   |         uint[] memory prevBalances = new uint[](tokensLength);
 127 |     |
 128 | *   |         for (uint i; i < tokensLength; i++) {
 129 | *   |             prevBalances[i] = IERC20(tokens[i]).balanceOf(address(this));
 130 |     |         }
 131 |     |
 132 |     |         // harvest rewards
 133 | *   |         iVault.getReward();
 134 |     |
 135 | *   |         uint _performanceFee = getPerformanceFee();
 136 | *   |         address _iRedToken = iRedToken();
 137 | *   |         address _ibgt = ibgt();
 138 | *   |         IIBGTVault _ibgtVault = IIBGTVault(ibgtVault());
 139 |     |         // re-stake iBGT, take performance fee and update accounting
 140 | *   |         for (uint i; i < tokensLength; i++) {
 141 | *   |             address _token = tokens[i];
 142 | *   |             uint newBalance = IERC20(_token).balanceOf(address(this));
 143 |     |
 144 | *   |             uint rewards = newBalance - prevBalances[i];
 145 | *   |             if (rewards == 0) continue; /// @dev Skip if no rewards, saves from iVault revert 'Cannot stake 0'
 146 |     |
 147 | *   |             (rewards, _token) = _autoCompoundHook(_token, _ibgt, _ibgtVault, rewards);
 148 | *   |             uint fee = rewards * _performanceFee / BP;
 149 | *   |             uint netRewards = rewards - fee;
 150 |     |
 151 | *   |             if (address(_ibgtVault) == address(this) && _token == _ibgt) {
 152 |     |                 iVault.stake(netRewards);
 153 |     |             }
 154 |     |             // Meanwhile the token doesn't has an oracle mapped, it will be processed as a donation
 155 |     |             // This will avoid returns meanwhile a newly Infrared pushed reward token is not mapped
 156 | *   |             if (_hasPriceFeed(_token) && _token != _iRedToken && !_isCollVault(_token)) {
 157 | *   |                 _increaseBalance(_token, netRewards);
 158 |     |
 159 |     |                 // First time the oracle happens to be mapped, we add the token to the rewardedTokens
 160 |     |                 // If token has no oracle map this won't be called, hence not DOS the vault at `totalAssets`
 161 | *   |                 _addRewardedToken(_token); // won't add duplicates
 162 |     |             }
 163 | *   |             if (fee > 0) {
 164 | *   |                 IERC20(_token).safeTransfer(getBeraborrowCore().feeReceiver(), fee);
 165 |     |             }
 166 |     |         }
 167 | *   |         _getInfraredCollVaultStorage().lastUpdate = uint96(block.timestamp);
 168 |     |     }
 169 |     |
 170 |     |     /** @dev See {IERC4626-totalAssets}. */
 171 |     |     /// @dev Virtual accounting to avoid donations, usdValue is scaled to 1e18, since `getPrice` returns a WAD scaled price
 172 | *   |     function totalAssets() public view override virtual returns (uint amountInAsset) {
 173 | *   |         uint usdValue;
 174 | *   |         address[] memory _rewardedTokens = rewardedTokens();
 175 | *   |         uint rewardedTokensLength = _rewardedTokens.length;
 176 | *   |         (
 177 |     |             address[] memory currentRewardTokens,
 178 |     |             uint currentRewardTokensLength
 179 | *   |         ) = _getVaultRewardTokens();
 180 |     |
 181 | *   |         uint assetPrice = getPrice(asset());
 182 | *   |         uint assetBalance = _isRewardedToken(asset()) ? 0 : getBalance(asset());
 183 |     |
 184 | *   |         for (uint i; i < rewardedTokensLength; i++) {
 185 | *   |             usdValue += _convertToValue(_rewardedTokens[i], true);
 186 |     |         }
 187 |     |
 188 |     |         // account new tokens that are being rewarded that have not been accounted for, have a price feed and are not iRED neither CollVaults
 189 | *   |         for (uint i; i < currentRewardTokensLength; i++) {
 190 | *   |             if (!_isRewardedToken(currentRewardTokens[i]) && _hasPriceFeed(currentRewardTokens[i]) && currentRewardTokens[i] != iRedToken() && !_isCollVault(currentRewardTokens[i])) {
 191 | *   |                 usdValue += _convertToValue(currentRewardTokens[i], false);
 192 |     |             }
 193 |     |         }
 194 | *   |         amountInAsset = usdValue.mulDiv(WAD, assetPrice) + assetBalance;
 195 |     |     }
 196 |     |
 197 |     |     /// @dev Called by DenManager, returns the share usd value
 198 | *   |     function fetchPrice() public view virtual returns (uint) {
 199 | *   |         uint _totalSupply = totalSupply();
 200 | *   |         if (_totalSupply == 0) return 0;
 201 | *   |         return totalAssets().mulDiv(getPrice(asset()), _totalSupply);
 202 |     |     }
 203 |     |
 204 | *   |     function getPrice(
 205 |     |         address token
 206 | *   |     ) public view virtual returns (uint) {
 207 | *   |         return getPriceFeed().fetchPrice(token);
 208 |     |     }
 209 |     |
 210 | *   |     function deposit(uint assets, address receiver) public override harvestRewards returns (uint shares) {
 211 | *   |         shares = super.deposit(assets, receiver);
 212 |     |
 213 | *   |         infraredVault().stake(assets);
 214 |     |
 215 | *   |         _increaseBalance(asset(), assets);
 216 |     |     }
 217 |     |
 218 | *   |     function mint(uint shares, address receiver) public override harvestRewards returns (uint assets) {
 219 | *   |         assets = super.mint(shares, receiver);
 220 |     |
 221 | *   |         infraredVault().stake(assets);
 222 |     |
 223 | *   |         _increaseBalance(asset(), assets);
 224 |     |     }
 225 |     |
 226 | *   |     function withdraw(uint assets, address receiver, address _owner) public override harvestRewards returns (uint shares) {
 227 | *   |         uint _totalSupply = totalSupply(); // cached to don't account for the burn
 228 |     |
 229 | *   |         { // scope to avoid stack too deep error
 230 | *   |             uint256 maxAssets = maxWithdraw(_owner);
 231 | *   |             if (assets > maxAssets) {
 232 | *   |                 revert ERC4626ExceededMaxWithdraw(_owner, assets, maxAssets);
 233 |     |             }
 234 |     |         }
 235 |     |
 236 | *   |         shares = previewWithdraw(assets);
 237 |     |
 238 | *   |         uint assetAmount = shares.mulDiv(getBalance(asset()), _totalSupply, Math.Rounding.Down);
 239 | *   |         infraredVault().withdraw(assetAmount);
 240 | *   |         _decreaseBalance(asset(), assetAmount);
 241 |     |
 242 | *   |         _withdraw(_msgSender(), receiver, _owner, assetAmount, shares);
 243 | *   |         _withdrawExtraRewardedTokens(receiver, shares, _totalSupply);
 244 |     |     }
 245 |     |
 246 |     |     /// @dev Decompounded redeem() function to reuse `previewRedeem()` on `infrared.withdraw`
 247 | *   |     function redeem(uint shares, address receiver, address _owner) public override harvestRewards returns (uint assets) {
 248 | *   |         uint _totalSupply = totalSupply(); // cached to don't account for the burn
 249 |     |
 250 | *   |         { // scope to avoid stack too deep error
 251 | *   |             uint256 maxShares = maxRedeem(_owner);
 252 | *   |             if (shares > maxShares) {
 253 | *   |                 revert ERC4626ExceededMaxRedeem(_owner, shares, maxShares);
 254 |     |             }
 255 |     |         }
 256 |     |
 257 | *   |         assets = previewRedeem(shares);
 258 |     |
 259 | *   |         uint bHoneyAmount = shares.mulDiv(getBalance(asset()), _totalSupply, Math.Rounding.Down);
 260 | *   |         infraredVault().withdraw(bHoneyAmount);
 261 | *   |         _decreaseBalance(asset(), bHoneyAmount);
 262 |     |
 263 | *   |         _withdraw(_msgSender(), receiver, _owner, bHoneyAmount, shares);
 264 | *   |         _withdrawExtraRewardedTokens(receiver, shares, _totalSupply);
 265 |     |     }
 266 |     |
 267 |     |     /// @dev Token out or received currency will always be the asset of the vault
 268 | *   |     function rebalance(IInfraredCollateralVault.RebalanceParams calldata p) external virtual onlyOwner {
 269 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 270 |     |
 271 | *   |         uint sentPrice = getPrice(p.sentCurrency);
 272 | *   |         uint receivedPrice = getPrice(asset());
 273 | *   |         uint8 sentDecimals = IAsset(p.sentCurrency).decimals();
 274 | *   |         uint sentCurrencyBalance = IAsset(p.sentCurrency).balanceOf(address(this));
 275 | *   |         uint receivedCurrencyBalance = IAsset(asset()).balanceOf(address(this));
 276 |     |
 277 |     |         // Perform the swap using the swapper contract
 278 | *   |         IERC20(p.sentCurrency).safeTransfer(p.swapper, p.sentAmount);
 279 | *   |         IRebalancer(p.swapper).swap(
 280 | *   |             p.sentCurrency,
 281 | *   |             p.sentAmount,
 282 | *   |             asset(),
 283 | *   |             p.payload
 284 |     |         );
 285 |     |
 286 | *   |         uint received = IAsset(asset()).balanceOf(address(this)) - receivedCurrencyBalance;
 287 | *   |         uint sent = sentCurrencyBalance - IAsset(p.sentCurrency).balanceOf(address(this));
 288 |     |
 289 | *   |         uint receivedValue = received.convertToValue(receivedPrice, decimals());
 290 | *   |         uint sentValue = sent.convertToValue(sentPrice, sentDecimals);
 291 |     |
 292 |     |         // if threshold isn't set, it will be 0, not tolerating any slippage
 293 | *   |         require(receivedValue >= sentValue * (BP - $.threshold[p.sentCurrency]) / BP, "CollVault: received amount is below threshold");
 294 |     |
 295 | *   |         $.balance[p.sentCurrency] -= sent;
 296 | *   |         $.balance[asset()] += received;
 297 |     |
 298 | *   |         _afterVaultRebalance(received);
 299 |     |     }
 300 |     |
 301 |     |     /// @dev `receiver` automatically receives `asset()` donations, and `tokens` and `amounts` donations as desired by the owner `amounts`
 302 | *   |     function receiveDonations(address[] memory tokens, uint[] memory amounts, address receiver) external virtual onlyOwner {
 303 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 304 |     |
 305 | *   |         uint tokensLength = tokens.length;
 306 |     |
 307 | *   |         require(tokensLength == amounts.length, "CollVault: tokens and amounts length mismatch");
 308 |     |
 309 | *   |         uint assetBalance = IERC20(asset()).balanceOf(address(this));
 310 | *   |         uint virtualBalance = $.balance[asset()];
 311 |     |
 312 | *   |         if (assetBalance > virtualBalance) {
 313 | *   |             IERC20(asset()).safeTransfer(receiver, assetBalance - virtualBalance);
 314 |     |         }
 315 |     |
 316 | *   |         for (uint i; i < tokensLength; i++) {
 317 | *   |             if (tokens[i] == asset()) {
 318 | *   |                 continue;
 319 |     |             }
 320 | *   |             uint256 tokenBalance = IERC20(tokens[i]).balanceOf(address(this));
 321 | *   |             uint256 virtualTokenBalance = $.balance[tokens[i]];
 322 | *   |             uint256 transferAmount = Math.min(amounts[i], tokenBalance - virtualTokenBalance);
 323 | *   |             if (transferAmount > 0) {
 324 | *   |                 IERC20(tokens[i]).safeTransfer(receiver, transferAmount);
 325 |     |             }
 326 |     |         }
 327 |     |     }
 328 |     |
 329 | *   |     function setPairThreshold(address tokenIn, uint thresholdInBP) external virtual onlyOwner {
 330 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 331 |     |
 332 | *   |         require(thresholdInBP <= BP, "CollVault: threshold > BP");
 333 |     |
 334 | *   |         $.threshold[tokenIn] = thresholdInBP;
 335 |     |     }
 336 |     |
 337 | *   |     function setPerformanceFee(uint16 _performanceFee) external virtual onlyOwner {
 338 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 339 |     |
 340 | *   |         require(_performanceFee >= $.minPerformanceFee && _performanceFee <= $.maxPerformanceFee, "CollVault: performance fee out of bounds");
 341 |     |
 342 | *   |         $.performanceFee = _performanceFee;
 343 |     |     }
 344 |     |
 345 | *   |     function _increaseBalance(address token, uint amount) internal virtual {
 346 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 347 | *   |         $.balance[token] += amount;
 348 |     |     }
 349 |     |
 350 | *   |     function _decreaseBalance(address token, uint amount) internal virtual {
 351 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 352 | *   |         $.balance[token] -= amount;
 353 |     |     }
 354 |     |
 355 | *   |     function getBalance(address token) public view virtual returns (uint) {
 356 | *   |         return _getInfraredCollVaultStorage().balance[token];
 357 |     |     }
 358 |     |
 359 | *   |     function getPerformanceFee() public view virtual returns (uint16) {
 360 | *   |         return _getInfraredCollVaultStorage().performanceFee;
 361 |     |     }
 362 |     |
 363 | *   |     function getBeraborrowCore() public view virtual returns (IBeraborrowCore) {
 364 | *   |         return _getInfraredCollVaultStorage()._beraborrowCore;
 365 |     |     }
 366 |     |
 367 | *   |     function getPriceFeed() public view virtual returns (IPriceFeed) {
 368 | *   |         return IPriceFeed(_getInfraredCollVaultStorage()._beraborrowCore.priceFeed());
 369 |     |     }
 370 |     |
 371 |     |     /// @dev Returns tokens that has been rewarded at some point by the infrared vault
 372 | *   |     function rewardedTokens() public view virtual returns (address[] memory) {
 373 | *   |         return _getInfraredCollVaultStorage().rewardedTokens.values();
 374 |     |     }
 375 |     |
 376 | *   |     function _isRewardedToken(address token) internal view virtual returns (bool) {
 377 | *   |         return _getInfraredCollVaultStorage().rewardedTokens.contains(token);
 378 |     |     }
 379 |     |
 380 | *   |     function _addRewardedToken(address token) internal virtual {
 381 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 382 | *   |         $.rewardedTokens.add(token);
 383 |     |     }
 384 |     |
 385 | *   |     function iRedToken() public view virtual returns (address) {
 386 | *   |         return _getInfraredCollVaultStorage().iRedToken;
 387 |     |     }
 388 |     |
 389 | *   |     function infraredVault() public view virtual returns (IInfraredVault) {
 390 | *   |         return _getInfraredCollVaultStorage()._infraredVault;
 391 |     |     }
 392 |     |
 393 | *   |     function ibgt() public view virtual returns (address) {
 394 | *   |         return _getInfraredCollVaultStorage().ibgt;
 395 |     |     }
 396 |     |
 397 | *   |     function ibgtVault() public view virtual returns (address) {
 398 | *   |         return _getInfraredCollVaultStorage().ibgtVault;
 399 |     |     }
 400 |     |
 401 |     |     /// @dev Rewards the rest of the rewarded tokens (not the asset) to the receiver
 402 | *   |     function _withdrawExtraRewardedTokens(
 403 |     |         address receiver,
 404 |     |         uint shares,
 405 |     |         uint _totalSupply
 406 |     |     ) internal virtual {
 407 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 408 |     |
 409 | *   |         address[] memory tokens = rewardedTokens();
 410 | *   |         uint tokensLength = tokens.length;
 411 | *   |         address _ibgtVault = $.ibgtVault;
 412 |     |
 413 | *   |         for (uint i; i < tokensLength; i++) {
 414 | *   |             address token = tokens[i];
 415 |     |             // if token is the asset, go next token since has already been transferred
 416 | *   |             if (token == asset()) {
 417 | *   |                 continue;
 418 |     |             }
 419 |     |
 420 | *   |             uint amount = shares.mulDiv($.balance[token], _totalSupply, Math.Rounding.Down);
 421 |     |
 422 | *   |             if (amount == 0) continue;
 423 | *   |             $.balance[token] -= amount;
 424 |     |
 425 | *   |             if (token == _ibgtVault && _ibgtVault != address(this)) {
 426 | *   |                 IInfraredCollateralVault(token).redeem(amount, receiver, address(this));
 427 |     |             } else {
 428 | *   |                 IERC20(token).safeTransfer(receiver, amount);
 429 |     |             }
 430 |     |         }
 431 |     |     }
 432 |     |
 433 |     |     /// @dev Returns the tokens that are currently being rewarded by the infrared vault
 434 | *   |     function _getVaultRewardTokens() internal view virtual returns (address[] memory tokens, uint tokensLength) {
 435 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 436 | *   |         IInfraredVault iVault = $._infraredVault;
 437 |     |
 438 | *   |         tokensLength = _getTokenLength(iVault);
 439 |     |
 440 | *   |         tokens = new address[](tokensLength);
 441 |     |
 442 | *   |         for (uint i; i < tokensLength; i++) {
 443 | *   |             tokens[i] = iVault.rewardTokens(i);
 444 |     |         }
 445 |     |     }
 446 |     |
 447 |     |     /// @dev `rewardTokens` is a public getter of a dynamic `address[]`, reverts out of bounds
 448 | *   |     function _getTokenLength(IInfraredVault iVault) private view returns (uint tokensLength) {
 449 |     |         // Determine the number of reward tokens
 450 |     |         /// @dev This assumes there are no gaps in the rewardTokens array
 451 | *   |         while (true) {
 452 | *   |             try iVault.rewardTokens(tokensLength) {
 453 | *   |                 ++tokensLength;
 454 |     |             } catch {
 455 | *   |                 break;
 456 |     |             }
 457 |     |         }
 458 |     |     }
 459 |     |
 460 | *   |     function _hasPriceFeed(address token) internal view virtual returns (bool) {
 461 | *   |         IPriceFeed priceFeed = getPriceFeed();
 462 |     |
 463 | *   |         (address oracle,,,,,) = priceFeed.oracleRecords(token);
 464 |     |
 465 | *   |         IPriceFeed.FeedType memory feedInfo = priceFeed.feedType(token);
 466 |     |
 467 | *   |         return oracle != address(0) || feedInfo.isCollVault || feedInfo.spotOracle != address(0);
 468 |     |     }
 469 |     |
 470 |     |     /// @param hasBeenRewarded if the token has been rewarded by the infrared vault at some point, not necessarily now
 471 | *   |     function _convertToValue(address token, bool hasBeenRewarded) public view virtual returns (uint) {
 472 | *   |         uint currentBalance = hasBeenRewarded ? getBalance(token) : 0; // save read
 473 | *   |         uint futureGrossEmission = infraredVault().earned(address(this), token);
 474 | *   |         uint futureEmission = futureGrossEmission.mulDiv(BP - getPerformanceFee(), BP, Math.Rounding.Up);
 475 | *   |         uint balance = currentBalance + futureEmission;
 476 | *   |         uint price = getPrice(token);
 477 | *   |         uint8 decimals = IAsset(token).decimals();
 478 | *   |         return balance.convertToValue(price, decimals);
 479 |     |     }
 480 |     |
 481 |     |     /**
 482 |     |      * @dev Hook that is called to check if the token is a collateral vault
 483 |     |      * @dev Prevents recursion DOS attacks by preventing the vault from being a reward token
 484 |     |      * Only collateral vault permitted is iBGTVault
 485 |     |      */
 486 | *   |     function _isCollVault(address token) internal view virtual returns (bool) {
 487 | *   |         IInfraredCollateralVault.InfraredCollVaultStorage storage $ = _getInfraredCollVaultStorage();
 488 |     |
 489 |     |         // iBGTVault is the only collateral vault permitted, unless it is the current vault
 490 | *   |         if (token == $.ibgtVault && $.ibgtVault != address(this)) {
 491 | *   |             return false;
 492 |     |         }
 493 | *   |         return getPriceFeed().isCollVault(token);
 494 |     |     }
 495 |     |
 496 |     |     function _autoCompoundHook(address _token, address /*_ibgt*/, IIBGTVault /*_ibgtVault*/, uint _rewards) internal virtual returns (uint, address) {
 497 |     |         return (_rewards, _token);
 498 |     |     }
 499 |     |
 500 |     |     /**
 501 |     |      * @dev Hook that is called after the vault has been rebalanced
 502 |     |      * Meant to be used by the child contract to stake the `asset()` in the infrared vault
 503 |     |      */
 504 |     |     function _afterVaultRebalance(uint amount) internal virtual {}
 505 |     | }
